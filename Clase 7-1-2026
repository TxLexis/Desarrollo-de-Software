CHECKLIST KISS (RÁPIDO)
  - ¿Hay abstracción prematura? (YAGNI)
  - ¿Hay herencia profunda? (Preferir composición)
  - ¿Estoy reiventando API estándar?
  - ¿Hay if anidados evitables? (Guard clauses)
  - ¿Puedo hacer datos inmutables/records?

¿QUÉ ES COHESIÓN?
Se mide dependiendo de que tan relacionado y enfocados estám los elementos de una clase o módulo.

  + ¿Porqué importa?
    - Facilita entender el código. (Menos "Saltos mentales").
    - Reduce el costo de cambiar. (Cambios locales).
    - Mejora la testibilidad. (Menos dependecias y escenarios).
    - Evita clases "Cajón de sastre".

  + Alta Cohesión: Todo está relacionado con cocinar, modificar una cosa solo afecta una parte y no todo. ✅
  + Baja Cohesión: Todo separado por cosas, que afecta el cambiar una cosa. ❌
      Problemas de Baja Cohesión:
        - Se convierte en un "Basurero" de funciones.
        - Difícil de nombrar con precisión.
        - cambios no relacionados se mezclan -> conflictos, regresiones.
        - Pruebas y mantenimiento se dispersa.


  + HEURISTICA 1: EL "TEST DEL NOMBRE"
    ✅: InvoiceCalculator, PasswordPolicy, OrderRepository
    ❌: Utils, Helper, Manager, CommonStuff
    - Si el nombre no indica una responsabilidad clara, sospecha.
  
  + HEURISTICA 2: "¿QUÉ CAMBIA JUNTO?"
    Alta cohesión significa que las razones de cambio son parecidad:
    - Si cambia la politica de impuestos -> afecta el calculo
    -
  
  + HEURITICA 3: "¿USAN LOS MISMOS DATOS?"
    En alta cohesion

--------------------------------------------------------------------------------------------------------------------

PRINCIPIO DE RESPONSABILIDAD ÚNICA (SRP)
- Un módulo o clase debe tener una sola responsabilidad.
- Esto signica que solo debe tener una cosa que cambiar.

  + Sintomas de Violación de SRP
    - La clase tiene métodos de muchos dominios (Cálculos +  archivos  + pantalla).  
    - Las pruebas son difíciles porque hay que probar todo a la vez.
    - La clase es muy larga y llena de utilidades variables.

  + Una clase, muchos motivos para cambiar
  + Dividir para vencer
    - Separamos las responsabilidades por "actor" o motivo de cambio.
    - Convertimos un bloque en piezas remplazables.
    - Creamos clases especialistas en una sola tarea.

  + Benefecios
    - Mantenibilidad
    - Pruebas
    - Reuso


CODIGO:

package ac.ucr.sa.principos;

import java.util.Calendar;
import java.util.Scanner;

public class AgeOldApp {

    public static void main(String[] args) {
        Calendar userDOB = captureUserBirth();
        ResultDOB result = calculateDOB(userDOB);
        printResult(result);
    }

    private static int capture(Scanner scanner, String label) {
        System.out.println("Ingrése " + label + ":");
        int value = scanner.nextInt();
        scanner.nextLine();
        return value;
    }

    private static Calendar captureUserBirth() {
        Scanner scanner = new Scanner(System.in);
        int day = capture(scanner, "día");
        int month = capture(scanner, "mes");
        int year = capture(scanner, "año");
        Calendar userDOB = Calendar.getInstance();
        userDOB.set(Calendar.DAY_OF_MONTH, day);
        userDOB.set(Calendar.MONTH, month);
        userDOB.set(Calendar.YEAR, year);
        return userDOB;
    }

    private static ResultDOB calculateDOB(Calendar userDOB) {
        int currentYear = Calendar.getInstance().get(Calendar.YEAR);
        int currentMonth = Calendar.getInstance().get(Calendar.MONTH) + 1;
        int currentDay = Calendar.getInstance().get(Calendar.DAY_OF_MONTH);

        int resultYear = currentYear - userDOB.get(Calendar.YEAR);
        int resultMonth = currentMonth - userDOB.get(Calendar.MONTH);
        if (resultMonth < 0)
            resultYear--;

        if (resultMonth < 0) {
            resultMonth = 12 + resultMonth;
        }

        int resultDay = currentDay - userDOB.get(Calendar.DAY_OF_MONTH);

        if (resultDay < 0) {
            resultMonth--;
            resultDay = 30 + resultYear; //TODO implementar luego la verifación de los días
        }

        return new ResultDOB(resultYear, resultMonth,  resultDay);
    }

    record ResultDOB(
            int year,
            int month,
            int day
    ) {
    }

    private static void printResult(ResultDOB result) {
        //Saloda: Tiene {} años, {} meses y {} días
        System.out.printf("Tiene %d años, %d meses y %d días", result.year(), result.month(), result.day());
    }
}


