# Resumen: Estructuras de Datos y Algoritmos

AquÃ­ tienes un resumen consolidado de los conceptos clave de los materiales proporcionados:

---

## ğŸ“Š **Estructuras de Datos Fundamentales**

### **Arreglos Unidimensionales (1D)**
- ColecciÃ³n de elementos del mismo tipo en posiciones contiguas
- Acceso directo por Ã­ndice: **O(1)**
- Operaciones:
  - **Insertar al final**: O(1)
  - **Insertar en posiciÃ³n especÃ­fica**: O(n)
  - **Eliminar**: O(n)
  - **Acceder/Modificar**: O(1)

### **Arreglos Bidimensionales (2D)**
- Estructura matricial (filas Ã— columnas)
- Acceso: `matriz[fila][columna]`
- Recorridos comunes:
  - Por filas, por columnas, diagonal
- Ãštil para: tablas, tableros de juego, imÃ¡genes

---

## ğŸ” **Algoritmos de BÃºsqueda**

### **BÃºsqueda Lineal**
- Recorre secuencialmente cada elemento
- **No requiere datos ordenados**
- Complejidad:
  - Mejor caso: O(1)
  - Promedio/Peor: O(n)

### **BÃºsqueda Binaria**
- Divide el espacio de bÃºsqueda a la mitad repetidamente
- **Requiere datos ordenados**
- Complejidad: **O(log n)** en todos los casos
- Mucho mÃ¡s eficiente para conjuntos grandes

---

## ğŸ”„ **Algoritmos de Ordenamiento**

### **Algoritmos BÃ¡sicos - O(nÂ²)**

| Algoritmo | Mejor Caso | Promedio | Peor Caso | Estable | In-Place |
|-----------|------------|----------|-----------|---------|----------|
| **Bubble Sort** | O(nÂ²) | O(nÂ²) | O(nÂ²) | âœ… SÃ­ | âœ… SÃ­ |
| **Bubble Sort Optimizado** | O(n) | O(nÂ²) | O(nÂ²) | âœ… SÃ­ | âœ… SÃ­ |
| **Selection Sort** | O(nÂ²) | O(nÂ²) | O(nÂ²) | âŒ No | âœ… SÃ­ |
| **Sinking Sort** | O(nÂ²) | O(nÂ²) | O(nÂ²) | âŒ No | âœ… SÃ­ |

**Usar cuando:** Conjuntos pequeÃ±os (< 50 elementos), simplicidad es prioridad

---

### **Algoritmos Eficientes - O(n log n)**

#### **Quick Sort**
- Estrategia: Dividir y conquistar
- Selecciona pivote, particiona, ordena recursivamente
- **Complejidad:**
  - Mejor/Promedio: **O(n log n)**
  - Peor caso: O(nÂ²) (pivote mal elegido)
- **Espacio:** O(log n)
- **In-place:** âœ… SÃ­ | **Estable:** âŒ No
- **Ventajas:** Muy rÃ¡pido en prÃ¡ctica, eficiente en memoria
- **Desventajas:** No estable, peor caso cuadrÃ¡tico

#### **Merge Sort**
- Estrategia: Dividir y conquistar
- Divide en mitades, ordena, combina
- **Complejidad:** **O(n log n)** en todos los casos
- **Espacio:** O(n)
- **In-place:** âŒ No | **Estable:** âœ… SÃ­
- **Ventajas:** Predecible, estable, paralelizable
- **Desventajas:** Requiere memoria adicional

---

## ğŸ”¤ **ManipulaciÃ³n de Cadenas (Strings)**

### **Operaciones Comunes**
- **Longitud:** `length()`
- **Acceso:** `charAt(i)` - O(1)
- **ConcatenaciÃ³n:** `+` o `concat()`
- **Subcadenas:** `substring(inicio, fin)`
- **BÃºsqueda:** `indexOf()`, `contains()`
- **Reemplazo:** `replace(viejo, nuevo)`
- **DivisiÃ³n:** `split(delimitador)`
- **ConversiÃ³n de caso:** `toUpperCase()`, `toLowerCase()`
- **Limpieza:** `trim()`

### **TÃ©cnicas de Parsing**
- ExtracciÃ³n de datos separados por delimitadores
- ValidaciÃ³n de formatos (email, contraseÃ±as)
- ExtracciÃ³n de nÃºmeros de texto
- Formateo e interpolaciÃ³n

---

## ğŸ“ˆ **NotaciÃ³n Big-O - Crecimiento de Complejidad**

**De mejor a peor:**

1. **O(1)** - Constante: acceso a arreglo, asignaciÃ³n
2. **O(log n)** - LogarÃ­tmica: bÃºsqueda binaria
3. **O(n)** - Lineal: recorrer un arreglo
4. **O(n log n)** - Lineal-logarÃ­tmica: Merge Sort, Quick Sort
5. **O(nÂ²)** - CuadrÃ¡tica: Bubble Sort, dobles bucles
6. **O(2â¿)** - Exponencial: combinaciones, fuerza bruta
7. **O(n!)** - Factorial: permutaciones

### **Reglas de CÃ¡lculo**
- **Secuencia:** O(f + g) â†’ tomar el tÃ©rmino dominante
- **Bucles anidados:** multiplicar complejidades
- **Condiciones:** tomar el peor camino
- **Constantes:** se ignoran (O(5n) â†’ O(n))

---

## âš ï¸ **Errores Comunes**

1. **Off-by-one:** Usar `i <= n` en lugar de `i <= n-1`
2. **Ãndices fuera de rango:** No validar lÃ­mites
3. **Confundir fila/columna** en matrices 2D
4. **MutaciÃ³n no intencional** de arreglos originales
5. **BÃºsqueda binaria en datos no ordenados**
6. **ComparaciÃ³n de strings sin considerar mayÃºsculas**

---

## ğŸ¯ **GuÃ­a de SelecciÃ³n de Algoritmos**

### **Â¿QuÃ© algoritmo usar?**

| Escenario | RecomendaciÃ³n |
|-----------|---------------|
| Datos pequeÃ±os (< 100) no ordenados | BÃºsqueda Lineal |
| Datos grandes, bÃºsquedas frecuentes | Ordenar + BÃºsqueda Binaria |
| Ordenar datos pequeÃ±os | Bubble Sort Optimizado |
| Ordenar datos grandes | **Quick Sort** o **Merge Sort** |
| Necesitas estabilidad | Merge Sort |
| Memoria limitada | Quick Sort (in-place) |
| Peor caso O(nÂ²) inaceptable | Merge Sort |
| Datos casi ordenados | Bubble Sort Optimizado |

---

## ğŸ’¡ **Consejos PrÃ¡cticos**

âœ… **Buenas PrÃ¡cticas:**
- Validar siempre los lÃ­mites de Ã­ndices
- Usar nombres descriptivos de variables
- Comentar lÃ³gica compleja
- DiseÃ±ar casos de prueba (normales, borde, extremos)
- Elegir algoritmo segÃºn tamaÃ±o de datos

âŒ **Evitar:**
- Usar algoritmos O(nÂ²) para datos grandes (> 1000)
- BÃºsqueda binaria en datos no ordenados
- Modificar arreglos sin copiarlos cuando sea necesario
- Ignorar la estabilidad cuando sea importante

---

## ğŸ“š **Casos de Prueba Esenciales**

Siempre probar con:
- **Arreglo vacÃ­o** (n = 0)
- **Un solo elemento** (n = 1)
- **Dos elementos**
- **Datos ya ordenados**
- **Datos en orden inverso**
- **Elementos duplicados**
- **Elemento no encontrado** (bÃºsquedas)

---

Este resumen cubre los conceptos fundamentales que necesitas dominar para trabajar eficientemente con estructuras de datos y algoritmos. Â¿Necesitas profundizar en algÃºn tema especÃ­fico?