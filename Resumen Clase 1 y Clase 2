Resumen: Principios de Diseño en Desarrollo de Software

Idea Central sobre Principios de Diseño + El diseño de software busca decisiones que produzcan sistemas:
- Fáciles de entender.
- Fáciles de cambiar.
- Difíciles de romper.

Problema real: el software cambia constantemente. Los principios de diseño son reglas guía (heurísticas) que ayudan a estructurar el código para reducir la complejidad y los costos de cambio. No son leyes absolutas; sacrificarlos puede ser válido en casos especiales, pero de forma consciente.

Enemigo común: Complejidad. (Incrementa con el tiempo necesario para entender y cambiar cosas).

Principios Fundamentales

1. Simplicidad (KISS)
+ KISS (Keep It Simple): Diseñar soluciones claras, directas y fáciles de cambiar.
+ Idea clave: La complejidad tiene costos (tiempo, bugs, y dificultades con refactorización).

+ Qué NO es KISS:
- No es reducir líneas de código sin sentido.
- No es evitar patrones siempre.
- No es crear código sin estructura.

+ Romper KISS:
- Abstracciones prematuras, interfaces abstractas innecesarias.
- Jerarquías profundas de herencia.
- Métodos con demasiados if anidados (‘arrow code’).
- Evitar la API estándar y reinventar funciones.

Estrategias Prácticas para KISS:
- KISS + YAGNI: No diseñar pensando en necesidades futuras (solo para requerimientos actuales). Ejemplo: Hoy: Crear una clase concreta basta. Mañana: Al aparecer otra implementación, se refactoriza.
- Prefiere composición sobre herencia: La herencia añade rigidez, mientras que la composición es flexible y modular.
- Usa la API estándar: Ejemplo: ❌ Iterar manualmente. ✅ Usar .stream().filter().toList() en Java.
- Retorno temprano: Evita if anidados validando los casos simples o errores al inicio.
- Usa inmutabilidad/Records: Propiedades inmutables reducen bugs y simplifican el entendimiento.

Checklist de KISS:
- ¿Hay abstracción prematura (YAGNI)?
- ¿Hay herencia innecesaria?
- ¿Reinvento algo que ya tiene la API estándar?
- ¿Hay if anidados evitables?
- ¿Puedo promover la inmutabilidad?

2. Cohesión
Definición: Qué tanto los elementos de una clase/módulo están relacionados entre sí.
- Alta Cohesión:
+ Todo dentro de la clase tiene un propósito claro y único.
+ Métodos trabajan sobre los mismos datos.
+ Cambios locales afectan solo la clase relacionada.

- Baja Cohesión:
+ Mezcla de responsabilidades sin propósito común (clases ‘cajón de sastre’).
+ Cambios en un área pueden romper otras.
+ Dificulta las pruebas y el mantenimiento.

Diagnóstico:
- ¿El nombre refleja un concepto único? (‘InvoiceCalculator’ ✅ vs. ‘Utils’ ❌).
- ¿Qué cambios afectan la clase? Motivos de cambio deben ser similares.
- ¿Los métodos comparten un conjunto de datos relacionados? Ejemplo:
- Alta Cohesión: Una clase ‘InvoiceCalculator’, donde todos los métodos calculan aspectos de una factura.
- Baja Cohesión: Una clase ‘Utils’ con métodos que no tienen relación directa entre sí.

3. Acoplamiento
Definición: Cuánto depende una clase de los detalles de otra.
- Alto Acoplamiento: Cambios en una clase (B) generan errores en otra (A). Ejemplo: Dependencia de detalles internos (‘a.getB().getC().doX()’).

- Síntomas:
+ Demasiado conocimiento sobre la estructura interna de otras clases.
+ Un cambio requiere editar múltiples partes del sistema.

- Bajo Acoplamiento: Interacción por interfaces y contratos, no por detalles internos. Beneficio: Las piezas son intercambiables sin dañar todo el sistema.

4. Principio de Responsabilidad Única (SRP)
Definición: Cada clase debe tener una sola responsabilidad o razón para cambiar.
- Clave: El motivo de cambio suele estar ligado a un actor (persona/área).

Síntomas de violación SRP:
- Métodos abarcando demasiados dominios.
- Dificultad de pruebas unitarias por entrelazado.
- Demasiado largo (clase monolítica).

Estrategias: Dividir responsabilidades en piezas separadas claras:
- Clase de Datos: Solo almacena cosas.
- Clase Lógica: Procesamiento.
- Clase Pantalla: Visual.

Ejemplo: Clase ‘Estudiante’ almacena básico. ‘Calculadora’ maneja promedios.

Beneficios SRP:
- Mejor mantenimiento y localización del problema.
- Reutilización en diversos contextos.

Conexión de Principios
Simplicidad y cohesión: Evitar entrelazamientos o magia. SRP refuerza enfoque directo minimizando acople.