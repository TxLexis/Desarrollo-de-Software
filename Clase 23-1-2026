--------> Interfaces y Clases Abstractas <--------

+ ¿Qué es una interfaz?
- Contrato: qué debe hacer una clase.
- Características:
  - Una clase puede implementar múltiples interfaces.
  - Útil para desacoplamiento y pruebas.

+ Desacoplamiento
- Programar contra la abstracción.

+ ¿Qué son Clases abstractas?
- No se puede instanciar directamente.
- Puede tener métodos abstractos y concretos.
- Puede tener estado (atributos).

+ ¿Interfaz o abstracta?
- Interfaz: contrato, sin estado compartido, máximo desacoplamiento.
- Abstracta: compartir código + estado, herencia simple, relación estable.


--------> Anti-patrones y calidad del diseño <--------

+ Anti-patrones (idea)
  + Señales de alerta
  - Diseño “funciona”, pero es difícil de cambiar
  - Aumenta el costo de mantenimiento
  - Baja testabilidad

+ Anti-patrón 1
  + Clase “Dios” +
  - Una clase hace “todo”
  - Rompe cohesión y SRP
  - Crece sin control

  + Cómo arreglarla (idea)
  - Separar por responsabilidad


+ Anti-patrón 2
  + Modelo anémico + 
  - Clases con datos + getters/setters
  - La lógica vive “afuera”
  - El objeto no protege reglas

  + Síntoma clave
  - “Las reglas no están donde viven los datos”
  - ServicioPedidos decide estados
  - Pedido permite estados inválidos
  - Difícil asegurar invariantes

  + Solución (idea)
  - Modelo rico en comportamiento
  - Métodos de negocio: procesar(), completar()
  - Validaciones internas
  - Estados con enum


+ Anti-patrón 3
  + Herencia innecesaria +
  - Herencia para “reusar campos”
  - Jerarquía rígida
  - No combina bien variaciones

  + Solución (idea)
  - Preferir composición
  - Empleado tiene-un ContactoInfo
  - El contacto puede tener email, teléfono o ambos


+ Herencia vs composición
- Herencia si hay “es-un” real y jerarquía estable
- Composición si se busca flexibilidad y evitar jerarquías profundas
- Regla de oro: si dudas, composición


--------> Creación de librerías reutilizables <--------

+ ¿Qué es una librería?
- Conjunto de clases e interfaces empaquetadas
- Resuelve un problema específico
- Se reutiliza en múltiples proyectos

+ Señales de una “buena” librería
- API clara y mínima
- Documentación completa
- Pruebas
- Versionado semántico

+ Idea clave
- Separar “público” vs “detalle”
- Interfaz: lo que el resto del proyecto depende
- Implementaciones: lo que puede cambiar sin romper usuarios


+ API mínima
- Contrato público (interfaz)
  public interface Validador {
    boolean esValido(String entrada);
    String mensajeError();
  }

+ Reglas para “API mínima”
- Menos métodos, mejor (pero suficientes)
- Evitar exponer detalles (regex, libs internas, etc.)
- Nombres que indiquen intención

+ Documentación (Javadoc)
  + Qué debe incluir
  - Qué hace la clase
  - Restricciones importantes
  - Ejemplo corto de uso
  - Versión (@since)

+ Pruebas (JUnit)
- Probar la librería sin UI, sin “main”
- Casos: válido, inválido, borde, nulo

+ Empaquetar como JAR (Gradle)
  + build.gradle (mínimo)
  - Plugin java-library
  - Dependencias de test
  - group y version


--------> Sobrecarga y Encadenamiento de Métodos <--------

+ Polimorfismo estático
  + Sobrecarga de métodos
  - Mismo nombre
  - Diferentes parámetros
  - Se resuelve en compilación

+ ¿Cuándo usar sobrecarga?
- Misma intención (misma “acción”)
- Cambio solo en tipos o cantidad de parámetros
- Evitar “semánticas distintas” con el mismo nombre

  + Riesgo 1: Semánticas distintas
    void log(String msg);
    void log(String msg, int level);
    void log(String msg, String level);
  - Fácil llamar “mal” y no darse cuenta
  - API difícil de aprender / mantener
  
  + Riesgo 2: Ambigüedad (mental)
  - Lectura del código
  - Si un método “parece otro”, el uso se vuelve error-prone
  - Preferir nombres explícitos cuando cambia la intención

+ Encadenamiento de métodos
  + Method chaining
  - Patrón: métodos retornan this para permitir llamadas encadenadas.

  + Ventaja
  - Código más legible
  - “Casi” lenguaje natural

  + Riesgos del chaining (nivel 1)
  - Si no hay validación → se crean estados inválidos
  - Si el orden importa → API frágil

  + Regla práctica (segura)
    + “Chaining + invariantes”
    - Validar en cada setter fluido o
    - Validar al final con build() (idea de Builder)

+ Sobrecarga + Chaining juntos
  + Diseñar APIs “amigables”
  - Sobrecarga: conveniencia (pocas variantes)
  - Chaining: legibilidad (configuración)
  - Prioridad: claridad > cleverness
