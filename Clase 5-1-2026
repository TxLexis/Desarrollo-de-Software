**Simplicidad**

**Cohesión**
Que tanto pertenecen juntos los elementos dentro de una clase/modulo.

**Acomplamiento**
Cuánto depende un módulo/clase de los detalles de otro.
Alto acoplamiento: Si cambias B, se rompe A.
Bajo acoplamiento: A depende de una interfaz/contrato, no de detalles.

**SRP**

- Relación entre principos (Intuición)
Simplicidad: menos pasos y menos magia.
Cohesión: Cada cosa en su lugar, con proposito claro.
Bajo acoplamiento: Piezas intercambiables sin romper todo.
SRP: Cada clase responde a un tipo de cambio (un actor).

CUANDO SE CUMPLE: El sistema se deja modificar sin miedo.

Analogía Final: Una casa bien diseñada
Simplicidad: Pasillos claros, distribución lógica.
Cohesión: Cocina para cocinar, baño para bañarse (No mezcla funciones).
Bajo acoplamiento: Puedes cambiar una lámpara sin reconstruir el techo.
SRP: Cada habitación tiene un proposito.

¿QUÉ ES KISS?
KISS (Keep It Simple Stupid): Diseñar y codificar de forma que la solución sea clara, directa y fácil de cambiar.
Idea clave: La complejidad tiene costo: Lectura, bugs, refactorings dolorosos.

La paradoja de la simplicidad: Lograr la simplicidad es ironicamente imposible.

¿QUÉ NO ES KISS?
- No es menos lineas a cualquier costo.
- No es código sin estructura.
- No es evitar patroes siempre.

SEÑALES DE QUE ESTÁS ROMPIENDO KISS
- Interfaces/clases abstractas por si acaso.
- Jerarquias profundas de herencia.
- Reimplementar cosas que ya existen en la plataforma.
- Métodos con muchos if anidados (arrow code).


**5 ESTRATEGIAS PARA APLICAR KISS**

1. KISS + YAGNI: NO ANTICIPES EL FUTURO
YAGNI: You Aren´t Gonna Need It
El Error: crear IService + AbstractService + ConcreteService cuando solo eciste un servicio.
Estrategia KISS: Construye para el requerimiento de hoy. Si mañana aparece una segunda implementación, refactorizadas.
Regla mental: Esperar a la terecera vez antes de generalizar.

CODIGO:

package ac.ucr.sa.principos;

import java.util.Calendar;
import java.util.Scanner;

public class AgeOldApp {

    public static void main (String[] args) {
        Scanner scanner = new Scanner(System.in);
        int day = capture(scanner, "día");
        int month = capture(scanner, "mes");
        int year = capture(scanner, "año");

        int currentYear = Calendar.getInstance().get(Calendar.YEAR);
        int currentMonth = Calendar.getInstance().get(Calendar.MONTH + 1);
        int currentDay = Calendar.getInstance().get(Calendar.DAY_OF_MONTH);

        int resultYear = currentYear-year;
        int resultMonth = currentMonth-month;
        if (resultMonth < 0)
            resultYear--;

        if (resultMonth < 0){
            resultMonth = 12 + resultMonth;
        }

        int resultDay = currentDay-day;

        if (resultDay <0){
            resultMonth--;
            resultDay = 30 + resultDay; //TODO implementar luego la verifación de los días
        }

        //Saloda: Tiene {} años, {} meses y {} días
        System.out.printf("Tiene %d años, %d meses y %d días", resultYear, resultMonth, resultDay);
    }

    private static int capture(Scanner scanner, String label){
        System.out.println("Ingrése " +  label + ":");
        int value = scanner.nextInt();
        scanner.nextLine();
        return value;
    }

}


2. PREFIERE COMPOSICIÓN SOBRE HERENCIA
Problema de herencia: Estructuras rígidas y fragiles, comportamientos ocultos de la jerarquia.

3. USA LA API ESTÁNDAR (NO REVIENTES LA RUEDA)
Más código propio = más mantenimiento, más pruebas.

4. RETORNO TEMPRANO

5. INMUTABILIDAD + RECORDS (JAVA 14+)

CODIGO:

package ac.ucr.sa.principos;

public class Student {

    private String name;
    private String Id;

    public Student(String name, String id) {
        this.name = name;
        Id = id;
    }

    public Student() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return Id;
    }

    public void setId(String id) {
        Id = id;
    }

}


